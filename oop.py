class Cat:
    species = 'Кошка простая'  # Атрибут класса: общий для всех экземпляров(вид - )
    
    # Инкапсуляция: прячем свойства объекта внутри класса
    # Скрытый атрибут (protected)
    def __init__(self, color, age):
        self.color = color  
        self._age = age     

    # Полиморфизм: один и тот же метод может работать по-разному в разных классах
    def make_sound(self):  
        return "Meow"

    def get_info(self):
        return f"Эта кошка цвета {self.color} и ей {self._age} лет"
    
    # Частный метод (protected)
    # def _secret_life(self):  
    #     return "Я люблю спать каждый день"
    
    # Частный метод (private)
    def __secret_life(self):  
        return "Я люблю спать каждый день"
    
    # Доступ к атрибуту класса через метод класса
    @classmethod
    def get_species(cls):
        return cls.species  
    
    @staticmethod
    def is_homelike():
        return True
    
    @property
    def age(self):
        return self._age
    
    def __str__(self):
        return f"Кошка {self.color} цвета, возраст: {self.age}"
    
    # Под вопросом прям!!!!
    def __repr__(self):
        return f"Cat(color={self.color}, age={self._age})"
    

class Lion(Cat):
    # Переопределяем атрибут класса для льва
    species = 'Кошка сложная'  

    # Полиморфизм: переопределяем метод для создания уникального поведения
    def make_sound(self):  
        return "Roar"
    
    def get_info(self):
        return f"Это лев и он {self.color} цвета и ему {self._age} лет"
    
    # Частный метод (protected)
    def _secret_life(self):  
        return "Я король джунглей!!!!!"
    
    # Львы не считаются одомашненными
    @staticmethod
    def is_homelike():
        return False  
    
    # Частный метод (private)
    def __secret_life(self):  
        return "Я король джунглей!!!!!"
    




# Создаем объект класса Cat
my_cat = Cat("black", 4)
print(my_cat.get_info())   
print(my_cat.make_sound()) 
print(my_cat.age)
print(my_cat)

print(dir(my_cat))  

print(Cat.get_species())           
print(my_cat.get_species())       

# Создаем объект класса Lion
simba = Lion("golden", 5)
print(simba.get_info())    
print(simba.make_sound())  


# Использование статических методов
print(Cat.is_homelike())   
print(Lion.is_homelike())  


# Попробуем вызвать скрытый метод - это плохая практика, но так можно сделать
print(my_cat._secret_life())  
print(simba._secret_life())   

print(Lion.get_species())          
print(simba.get_species())        



# Доступ к частным атрибутам через манглинг имен
print(my_cat._Cat__secret_life())  
print(simba._Lion__secret_life())  




'''
Инкапсуляция — это принцип, который помогает прятать детали реализации объекта и
предоставлять только необходимые методы для взаимодействия с ним. В нашем классе
Cat, свойства color и age являются частями объекта, которые мы можем задать при 
создании объекта, но они не видны напрямую другим объектам. 

Наследование позволяет создавать новый класс на основе существующего. 
Теперь давайте создадим подкласс Lion, который наследуется от класса Cat, 
но имеет свои особенности.

Полиморфизм — это принцип, позволяющий использовать один и тот же метод с разными 
объектами. В классе Lion мы переопределили метод make_sound, чтобы он выдавал 
звук, свойственный льву, а не кошке. 



- Инкапсуляция — это как когда ты хранишь свои игрушки в ящике и не даешь всем посмотреть, 
что там внутри, но легко можешь достать любую игрушку по своему желанию.

- Наследование — это когда младший брат или сестра учится делать что-то у старшего, 
но добавляет что-то свое, например, ты умеешь кататься на велосипеде, а твой брат 
или сестра тоже учится, но на трехколесном.

- Полиморфизм — это как играть в одну и ту же игру с разными правилами в зависимости от того, 
с кем ты играешь. Например, шарики можно катать по полу, а можно использовать в 
игре в баскетбол, чтобы кидать в корзину.
'''


# https://proproprogs.ru/python


'''
classmethod
Часто используется для создания экземпляров класса (фабрики), 
для работы с атрибутами класса или для других операций, 
которые связаны с классом, но не с конкретным его экземпляром.

Взаимодействие с наследуемыми классами:
- Методы класса могут быть полезны для операций, которые зависят от контекста класса, из которого они вызываются. Это полезно в иерархиях наследования.


ИСПОЛЬЗОВАНИЕ @classmethod стало общепринятой практикой в 
Python по нескольким причинам:

1. Явное указание на связь с классом:
   - Использование @classmethod делает код более читаемым. Это явным образом 
   сигнализирует, что метод работает с классом, а не с конкретным экземпляром.

Разделение ответственности:
   - Иногда логично разделить функциональность между методами экземпляра и 
   методами класса. Методы класса могут работать с атрибутами и состоянием, 
   которое должны разделять все экземпляры класса.

Хотя ты можешь добиться аналогичной функциональности без @classmethod, 
используя простые функции или методы экземпляра, применение @classmethod 
делает код более структурированным и поддерживаемым, особенно в крупных 
и сложных проектах.




**staticmethod**:
    - Используется, когда метод не зависит от экземпляра или класса и 
    не нуждается в доступе ни к каким атрибутам класса или экземпляра.
    - Метод не принимает ни self, ни cls в качестве первого параметра.
    - Часто используется для вспомогательных функций, которые логически связаны 
    с классом, но не требуют доступа к его внутренним данным.

Полезно когда:
- Когда нужно защитить внутренние атрибуты класса от изменения извне, 
предоставляя контролируемый доступ к ним.
    
Например: 

class MathOperations:
    @staticmethod
    def multiply(x, y):
        return x * y

result = MathOperations.multiply(6, 7)
print(result)


@property
Этот подход делает возможным доступ и управление приватными атрибутами, 
а также поддержку вычисляемых свойств, как будто они являются обычными 
атрибутами. Использование @property способствует созданию более чистого 
и инкапсулированного кода, позволяя скрыть сложность логики доступа к 
данным от пользователя класса.



### Исполнение @classmethod

1. Почему cls: 
   - cls используется в качестве первого аргумента метода класса по аналогии 
   с self, который используется как первый аргумент для обычных методов экземпляра. 
   Это делается для единообразия и ясности, но можно использовать и другие имена.

### Альтернативные синтаксисы

2. Применение к классу иным способом:
   - Хотя можно назвать первый аргумент другим именем, использование cls 
   является общепринятым соглашением. Вот альтернативный способ написания, 
   который, тем не менее, крайне не рекомендуется, так как это может запутать 
   других программистов:

    @classmethod
    def get_species(class_object):
        return class_object.species

3. Без использования @classmethod:
   - Если вы не хотите использовать декоратор @classmethod, вы можете 
   просто сделать метод, который явно принимает класс как аргумент:

    def get_species_no_decorator(class_type):
        return class_type.species

    species = get_species_no_decorator(Cat)






















    class Animal:
        @classmethod
        def who_am_i(cls):
            return f"I am {cls.name}"

    class Dog(Animal):
        pass

    class Cat(Animal):
        pass

    print(Dog.who_am_i())  # I am Dog
    print(Cat.who_am_i())  # I am Cat


Создание альтернативных конструкторов:
- classmethod часто используется для создания дополнительных конструкторов для класса. 
Например, это полезно, когда нужно создать объекты различными способами.

    
Python

python
    class Cat:
        species = 'Felis catus'

        def init(self, color, age):
            self.color = color
            self.__age = age

        @classmethod
        def from_birth_year(cls, color, birth_year):
            age = 2023 - birth_year
            return cls(color, age)
        
        def get_info(self):
            return f"Эта кошка цвета {self.color} и ей {self.__age} лет"

    cat = Cat.from_birth_year("серый", 2018)
    print(cat.get_info())  # Эта кошка цвета серого и ей 5 лет.


В этом примере свойства area и perimeter 
не являются атрибутами, хранящими значения в прямом виде, 
но предоставляют интерфейс для их вычисления, словно это обычные атрибуты.

class Rectangle:
    def init(self, width, height):
        self.width = width
        self.height = height

    @property
    def area(self):
        return self.width * self.height

    @property
    def perimeter(self):
        return 2 * (self.width + self.height)


rect = Rectangle(5, 10)
print(rect.area)      
print(rect.perimeter) 



Читабельность и простота использования: 
Вы можете использовать property так, как если бы это 
были обычные атрибуты, что упрощает код.
'''




'''
!!! Абстракция, если спросят !!!

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

# Создаем объекты животных
dog = Dog()
cat = Cat()

print(dog.make_sound())  # Выведет: Woof!
print(cat.make_sound())


1. Абстрактный класс: Это класс, который не может быть напрямую инстанцирован 
и может содержать абстрактные методы (методы без реализации).

2. Абстрактный метод: Это метод, который объявляется в абстрактном классе и 
должен быть реализован в подклассах.

3. Интерфейс: Абстрактный класс также может использоваться для создания общего 
интерфейса, который должны реализовать все подклассы.

Основными целями абстракции являются:
- Сокрытие сложностей реализации.
- Чёткое разделение интерфейса и реализации.
- Создание общих понятий, которые могут быть описаны на высоком уровне.
'''